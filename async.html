<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Async</title>
</head>
<body>

    <style>
        body{background-color: #444;color:#ddd;font-family: Arial, Helvetica, sans-serif;}
        #animationTarget{
            position: absolute;
            width:50px;height: 50px;border-radius: 50%;background-color:red;
            top: 100px;left:100px;
            box-shadow: inset 2px -1px 28px -7px #000000, 
                              2px -1px 28px -7px #fff,
                              2px -1px 50px -7px #fff;
        }
    </style>
    <div id="outlet">

    </div>

    <div id="animationTarget"></div>

    <script>

        //****** LOGGER
let lastRowId = 0;
function getLastRowFromSection(sectionTitle){
    if (sectionTitle) {
        let section = document.querySelector(`[data-title = "${sectionTitle.replace(/ /g,'')}"]`);
        let allRows = section.querySelectorAll('.row');
        if (allRows.length === 0) throw new Error('No rows in section ' + sectionTitle);
        return allRows[allRows.length - 1];
    }
    return document.getElementById(lastRowId + '');
}
function log(content, color, sectionTitle){
    // let outlet = document.querySelector(`[data-attr = ${sectionTitle}]`) ?? document.getElementById(lastRowId + '');
    let outlet = getLastRowFromSection(sectionTitle);
    let span = document.createElement('span');
    span.innerText = content;
    if (color) span.style.color = color;
    outlet.appendChild(span);
}
function newLogSection(sectionTitle){
    let outlet = document.getElementById('outlet');
    let newSection = document.createElement('div');
    newSection.classList.add('section');
    newSection.setAttribute('data-title', sectionTitle.replace(/ /g,''));
    newSection.innerHTML = `<h3>${sectionTitle}</h3>`;
    outlet.appendChild(newSection);
}

function newLogRow(sectionTitle){
    lastRowId += 1;
    sectionTitle = sectionTitle == undefined ? undefined : sectionTitle.replace(/ /g,'')
    let outlet = document.querySelector(`[data-title = "${sectionTitle}"]`) ?? document.getElementById('outlet');
    let newRow = document.createElement('div');
    newRow.classList.add('row');
    newRow.setAttribute('id', lastRowId + '');
    outlet.appendChild(newRow);
}
function endSection(){
    let outlet = document.getElementById('outlet');
    let hr = document.createElement('div');
    hr.classList.add('sectionSeparator')
    hr.innerHTML = '<hr>'
    outlet.appendChild(hr);
    newLogRow();
}

newLogRow();



// ************* TIMER **************

class Timer{
    constructor(){
        this.currentTime = 0;
        this.timer = null;
    }
    startTimer(){
        this.timer = setInterval(()=>{
            this.currentTime += 10;
        },10)
    }
    stopTimer(){
        clearInterval(this.timer);
    }
    resetTimer(){
        this.currentTime = 0;
    }
    getCurrentTime(){
        return this.currentTime;
    }
}



//*************************** 
// EXAMPLES
//*****************
let SECTION_1 = 'Async function returns a promise';

let resolveFunctionFactory = function(timeout, logSectionTitle){
    return function(msgStart, msgEnd, msgResolve){
        let signature = `  [[resolve${timeout}]]: `
        if(msgStart || msgEnd) newLogRow(logSectionTitle);
        if(msgStart) log(signature + msgStart, 'white', logSectionTitle);
        return new Promise(resolve => {
            setTimeout(function() {
                resolve(signature + msgResolve);
                log(signature + msgEnd, 'white', logSectionTitle)
            }, timeout)
        })
    }
}
newLogSection(SECTION_1);
let resolve100 = resolveFunctionFactory(100, SECTION_1);
let resolve150 = resolveFunctionFactory(150, SECTION_1);

async function asyncBug1(){
    let a = await resolve100(' [start async1] ', ' [end async1] ', ' resolved bug1');
    log(a, 'green', SECTION_1)
    return ' some str '; // WILL return a promise anyway
}
log(asyncBug1(), 'yellow', SECTION_1);
// This works
// [[resolve100]]: [start async1] [object Promise] [[resolve100]]: [end async1] [[resolve100]]: resolved bug1
// but [object Promise] is returned, as an async function always returns a PROMISE
// To know the actual value returne by asyncBug1, a wrapper could help

async function asyncBug1Wrapper(){
    let result = await asyncBug1();
    newLogRow(SECTION_1);
    log(result, SECTION_1);
}
asyncBug1Wrapper();

// However the result is still packed in a function, and may not be taken out from async

// **************************************
endSection();

let SECTION_2 = "Attempt to return a value with an async function not having an await statement"
newLogSection(SECTION_2);
newLogRow(SECTION_2);
async function asyncReturnValue(){
    return 1;
}
log(asyncReturnValue(),'white',SECTION_2); // [object Promise]
log(`  A async function always returns a promise, even if a return statement with a concrete value is used`,'#aaa',SECTION_2);

endSection();


// ************** ASYNC execution order ******************
let SECTION_3_1 = "Async execution order - sequential start"
newLogSection(SECTION_3_1);
newLogRow(SECTION_3_1);

let timer = new Timer();

let resolve100_3_1 = resolveFunctionFactory(100, SECTION_3_1);
let resolve150_3_1 = resolveFunctionFactory(150, SECTION_3_1);

async function sequentialStartRace(){
    timer.startTimer();
    let f1 = await resolve100_3_1(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_1);
    log(timer.getCurrentTime(), 'green', SECTION_3_1);
    newLogRow(SECTION_3_1);
    let f2 = await resolve150_3_1(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_1);
    log(timer.getCurrentTime(), 'green', SECTION_3_1);
    newLogRow(SECTION_3_1);
    timer.stopTimer();
    return f2;  // If not for this undefined would be returned, and in this case [[resolve150]]: [resolved]
    return 'value' // in this case function outcome would resolve to 'value' finally, but in reality the 
    // promise would be returned and would be resolved to 'value' afnter all promises are awaited.
}
(async function wrapSequentialStart(){
    newLogRow(SECTION_3_1);
    let outcome = await sequentialStartRace();
    log('Sequential async call will return: ', '#aaa')
    log(outcome, 'orange')
})();


let timer2 = new Timer();

let SECTION_3_2 = "Async execution order - concurrent start"
newLogSection(SECTION_3_2);
newLogRow(SECTION_3_2);


let resolve100_3_2 = resolveFunctionFactory(100, SECTION_3_2);
let resolve150_3_2 = resolveFunctionFactory(150, SECTION_3_2);

async function concurrentStartRace(){
    // timer2.startTimer();
    let f1 = resolve100_3_2(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_2);
    log(timer2.getCurrentTime(), 'green', SECTION_3_2);
    newLogRow(SECTION_3_2);
    let f2 = resolve150_3_2(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_2);
    log(timer2.getCurrentTime(), 'green', SECTION_3_2);
    newLogRow(SECTION_3_2);
    // timer2.stopTimer();
    // return (f2)
}
async function concurrentStartRaceWrapper(){
    timer2.startTimer();
    let result = await concurrentStartRace();
    log(timer2.getCurrentTime(), 'green', SECTION_3_2);
    timer2.stopTimer();
    log(`
    Timer shows 0, as wrapped function returns only the default promise, if 
    it had a return f2 or return f1 statement then the time of settling this promise would be 
    visible. In this example both functions start at the same time, and promise related to f1 would be resolved after
    100ms, and promise related to f2 would be resolved after 150ms
    `, '#aaa', SECTION_3_2)
}

concurrentStartRaceWrapper();






let timer3 = new Timer();

let SECTION_3_3 = "Async execution order - promise.all"
newLogSection(SECTION_3_3);
newLogRow(SECTION_3_3);


let resolve100_3_3 = resolveFunctionFactory(100, SECTION_3_3);
let resolve150_3_3 = resolveFunctionFactory(150, SECTION_3_3);



async function promiseAllRace(){
    timer3.startTimer();

    await Promise.all([
        (async()=>{
            let resolved = await resolve100_3_3(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_3);
            newLogRow(SECTION_3_3);
            // resolve(resolved);
        })(),
        (async()=>{
            let resolved = await resolve150_3_3(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_3);
            newLogRow(SECTION_3_3);
            // resolve(resolved);
        })()
    ])
    log(timer3.getCurrentTime(), 'green', SECTION_3_3);
    timer3.stopTimer();
}


promiseAllRace();
log(`Both start at the same time, then the first one (100) finishes, and then the second one (150)`
, '#aaa', SECTION_3_3);






let timer4 = new Timer();

let SECTION_3_4 = "Async execution order - promise.reace"
newLogSection(SECTION_3_4);
newLogRow(SECTION_3_4);


let resolve100_3_4 = resolveFunctionFactory(100, SECTION_3_4);
let resolve150_3_4 = resolveFunctionFactory(150, SECTION_3_4);



async function promiseRaceRace(){
    timer4.startTimer();

    await Promise.race([
        (async()=>{
            let resolved = await resolve100_3_4(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_4);
            newLogRow(SECTION_3_4);
            // resolve(resolved);
        })(),
        (async()=>{
            let resolved = await resolve150_3_4(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_4);
            newLogRow(SECTION_3_4);
            // resolve(resolved);
        })()
    ])
    log(timer4.getCurrentTime(), 'green', SECTION_3_4);
    timer4.stopTimer();
}


promiseRaceRace();
log(`Both promises are resolved, but the first one is returned as a result of the promise race`
, '#aaa', SECTION_3_4);



// *************************************
// Promises then catch finally

let timer5 = new Timer();

function rejectFunctionFactory(timeout, logSection){
    return function(reason){
        let rejectedPromise = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                newLogRow(logSection);
                log('[[ Rejected ]]: ' + reason);
                reject(reason)
            }, timeout)
        })
        return rejectedPromise;
    }
}
function resolveFunctionFactory2(timeout, logSection){
    return function(value){
        let resolvedPromise = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                newLogRow(logSection);
                log('[[ Resolved ]]: ' + value);
                resolve(value);
            },timeout)
        })
        return resolvedPromise;
    }
}

function errorFactory(logSection){
    return function(errorAsString){
        newLogRow(logSection);
        log(errorAsString);
        throw new Error(errorAsString);
    }
}



let SECTION_4 = ".then, .catch, .finally"
newLogSection(SECTION_4);
newLogRow(SECTION_4);

let rejectPromise = rejectFunctionFactory(100, SECTION_4);
let resolvePromise = resolveFunctionFactory2(120, SECTION_4);

timer5.startTimer();
function t() {return timer5.getCurrentTime()}

resolvePromise('1 ')
    .then(
            ()=>{return resolvePromise('2 ' + t())}, 
            ()=>{return rejectPromise('2 ' + t())}
        )
    .then(
            ()=>{return resolvePromise('3 ' + t())}, 
            ()=>{return rejectPromise('3 ' + t())}
        )
    .catch(
            ()=>{newLogRow(SECTION_4); log('catch after 3' + t()); return 'catch 3' + t()}
        )
    .then(
            ()=>{return resolvePromise('4 ' + t())}, 
            ()=>{return rejectPromise('4 ' + t())}
        )
    .then(
            ()=>{return rejectPromise('5 ' + t())}, // The first argument is always the resolve case, so
            // if reject is passed as the only one arg, then the secod arg is by dafauld undefined and 
            // the case on success will be finalized with rejection
        )
    .catch(
            ()=>{newLogRow(SECTION_4); log('catch after 5: ' + t()); return 'catch 5' + t()}
        )
    .finally(
            ()=>{newLogRow(SECTION_4); log('Final action  ' + t()); timer5.stopTimer();  'final'}
        )
        // [[ Resolved ]]: 1
        // [[ Resolved ]]: 2 120
        // [[ Resolved ]]: 3 240
        // [[ Resolved ]]: 4 360
        // [[ Rejected ]]: 5 480
        // catch after 5: 580
        // Final action 580




let timer6 = new Timer();
let SECTION_5 = ".then, .catch, .finally - catch launched in the middle of the chain"
newLogSection(SECTION_5);
newLogRow(SECTION_5);

let rejectPromise5 = rejectFunctionFactory(100, SECTION_5);
let resolvePromise5 = resolveFunctionFactory2(120, SECTION_5);

timer6.startTimer();
function t() {return timer6.getCurrentTime()}

resolvePromise5('1a ')
    .then(
            ()=>{return resolvePromise5('2a ' + t())}, 
            ()=>{return rejectPromise5('2a ' + t())}
        )
    .then(
            ()=>{return rejectPromise5('3a ' + t())}, 
            ()=>{return rejectPromise5('3a ' + t())}
        )
    .catch(
            ()=>{newLogRow(SECTION_5); log('catch after 3a' + t()); return 'catch 3a' + t()}
        )
    .then(
            ()=>{
                log(`this then reject function (second callback) will never be called, as there was a catch before this
                that was fired and this did the job.`)
                return rejectPromise5('4a ' + t())
            }, 
            ()=>{return rejectPromise5('4a ' + t())}
        )
    .then(
            ()=>{return rejectPromise5('5a ' + t())}, // The first argument is always the resolve case, so
            // if reject is passed as the only one arg, then the secod arg is by dafauld undefined and 
            // the case on success will be finalized with rejection
        )
    .catch(
            ()=>{newLogRow(SECTION_5); log('catch after 5a: ' + t()); return 'catch 5a' + t()}
        )
    .finally(
            ()=>{newLogRow(SECTION_5); log('Final action  ' + t()); timer6.stopTimer();  'final'}
        )




let timer7 = new Timer();
let SECTION_6 = ".then, .catch, .finally - throwing errors"
newLogSection(SECTION_6);
newLogRow(SECTION_6);

let rejectPromise6 = rejectFunctionFactory(100, SECTION_6);
let resolvePromise6 = resolveFunctionFactory2(120, SECTION_6);
let throeError6 = errorFactory(SECTION_6);


timer6.startTimer();
function t() {return timer6.getCurrentTime()}

resolvePromise6('1a ')
    .then(
            ()=>{return resolvePromise6('2a ' + t())}, 
            ()=>{return rejectPromise6('2a ' + t())}
        )
    .then(
            ()=>{
                    throwError6('Error in 3a, before promise resolved')
                    return resolvePromise6('3a ' + t())
            }, 
            ()=>{return rejectPromise6('3a ' + t())}
        )
    .catch(
            ()=>{newLogRow(SECTION_6); 
                log('[[ Catch ]]: ' + t()); 
                log(' catch after 3a called, due to error in previous resolved function ', '#aaa'); 
                return Promise.reject();
                return 'catch 3a' + t()}
        )
    .then(
            ()=>{
                newLogRow(SECTION_6);
                log(` This is called, because last then was resolved. With error, but resolved.`, '#aaa')
                return rejectPromise6('4a ' + t())
            }, 
            ()=>{return rejectPromise6('4a ' + t())}
        )
    .then(
            ()=>{return rejectPromise6('5a ' + t())}, // The first argument is always the resolve case, so
            // if reject is passed as the only one arg, then the secod arg is by dafauld undefined and 
            // the case on success will be finalized with rejection
        )
    .catch(
            ()=>{newLogRow(SECTION_6); log('catch after 5a: ' + t()); return 'catch 5a' + t()}
        )
    .finally(
            ()=>{newLogRow(SECTION_6); log('Final action  ' + t()); timer6.stopTimer();  'final'}
        )




// **** ANIMATION

// animationTarget

function move(animationTargetId, destination, timeInMiliseconds){
        let framesPerSecond = 24;
        let msInSecond = 1000;
        let framesInterval = Math.floor(framesPerSecond / msInSecond);
        let nrOfFrames = timeInMiliseconds * framesPerSecond / msInSecond;
        let animationTarget = document.getElementById(animationTargetId);
        let {x:xEnd, y:yEnd} = destination;
        let {left: xStart, top: yStart} = animationTarget.getBoundingClientRect();
        let xMovePerFrame = (xEnd - xStart)/nrOfFrames;
        let yMovePerFrame = (yEnd - yStart)/nrOfFrames;
        let {currentX, currentY} = {currentX: xStart, currentY: yStart};
        let currentFrame = 0;
        console.log('move Started')
        let moveEnded = new Promise((resolve) => {
                let interval = setInterval(()=>{
                currentX += xMovePerFrame;
                currentY += yMovePerFrame;
                currentFrame += 1;
                animationTarget.style.left = currentX + 'px';
                animationTarget.style.top = currentY + 'px';
                if (currentFrame >= nrOfFrames) {
                    clearInterval(interval);
                    console.log('move resolved')
                    resolve();
                }
            },framesInterval);
        })
        return moveEnded;
    }

function wait(timeInMiliseconds){
    let waitingEnded = new Promise((resolve) => {
        let timeout = setTimeout(()=>{
            console.log('waiting ended')
            resolve();
        }, timeInMiliseconds)
    })
    console.log('waiting')
    return waitingEnded;
}

// move('animationTarget', {x: 500, y:500}, 2000).then(wait(1000)).then(move('animationTarget', {x: -500, y: -500}, 1000));
async function animateAwait(){
    await move('animationTarget', {x: 500, y:500}, 2000)
    await wait(1000)
    await move('animationTarget', {x: 500, y: 100}, 1000);
    await move('animationTarget', {x: 550, y: 1000}, 1000);
    await wait(1000);
    await move('animationTarget', {x: 100, y: 100}, 3000);

}
// animatieAwait();
async function animateThen(){
    // Here it is important to wrap handlers, so they return functions not taking any arguments:
    move('animationTarget', {x:1000, y: 1000}, 3000)
        .then(()=>{return wait(1000)})
        .then(()=>{return move('animationTarget', {x:500,y:500}, 2000)})
        .then(()=>{return wait(3000)})
        .then(()=>{return move('animationTarget', {x:-500,y:-500}, 5000)})
}
async function animateAll(){
    await animateAwait();
    await animateThen();
}
animateAll();






// let SECTION_6 = ".then with values returned"
// newLogSection(SECTION_6);
// newLogRow(SECTION_6);

// let rejectPromise6 = rejectFunctionFactory(100, SECTION_6);
// let resolvePromise6 = resolveFunctionFactory2(120, SECTION_6);

// resolvePromise6().then((val)=>{
//     newLogRow(SECTION_6);
//     log(val)
// })








function promiseWithError(){
    return new Promise((resolve, reject) => {
        throw new Error('error thrown');
        resolve('resolved');
    })
}
(async function awaitPromiseWithError() {
    console.log('%cresolving promise with error ', 'background-color: yellow');
    let outcome = await promiseWithError().catch(()=>{return 'error handle'});
    console.log(outcome);
    console.log('%c'+outcome, 'background-color: yellow');
})();


(async function whatThenReturns(){
    let p1 = new Promise((resolve)=>{
        resolve('whatThenReturns resolved')
    });
    let p2 = new Promise((reject)=>{
        reject('thenRejected')
    });

    console.log(await p1.then(()=>{}))//{return 'then resolved' }))
    console.log(await p1.then(()=>{return 'then resolved' }))
    console.log(await p1.then('then with just a value'));
    console.log(await p2.then('resolve P2', 'reject P2'))
})();



(async function executionOrder(){
    let pOK = () => { return new Promise((resolve)=>{resolve('Resolved')}) };
    let pNOK = () => { return new Promise((reject)=>{reject('Rejected')}) };

    let resolved = pOK().then(pOK, pNOK);
    let rejected = pOK().then(pNOK, pOK);
    console.log(resolved);
    console.log(rejected);
})();



(async function canResolveAfterRejection(){

    let SECTION_7 = "can resolve after rejection in chain"
    newLogSection(SECTION_7);
    newLogRow(SECTION_7);

    let pOK = () => { 
        newLogRow(SECTION_7);
        log('resolved', 'green')
        return new Promise((resolve)=>{resolve('Resolved')}) 
    };
    let pNOK = () => { 
        newLogRow(SECTION_7);
        log('rejected', 'red')
        return new Promise((reject)=>{reject('Rejected')}) 
    };

    canResolve = pOK().then(pOK,pNOK).then(pNOK,pOK).then(pOK, pNOK)
    newLogRow(SECTION_7);
    log(await canResolve)

})();



    </script>
    
</body>
</html>