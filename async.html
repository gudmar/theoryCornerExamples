<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Async</title>
</head>
<body>

    <style>
        body{background-color: #444;color:#ddd;font-family: Arial, Helvetica, sans-serif;}
        #animationTarget{
            position: absolute;
            width:50px;height: 50px;border-radius: 50%;background-color:red;
            top: 100px;left:100px;
            box-shadow: inset 2px -1px 28px -7px #000000, 
                              2px -1px 28px -7px #fff,
                              2px -1px 50px -7px #fff;
        }
    </style>
    <div id="outlet">

    </div>

    <div id="animationTarget"></div>

    <script>

        //****** LOGGER
let lastRowId = 0;
function getLastRowFromSection(sectionTitle){
    if (sectionTitle) {
        let section = document.querySelector(`[data-title = "${sectionTitle.replace(/ /g,'')}"]`);
        let allRows = section.querySelectorAll('.row');
        if (allRows.length === 0) throw new Error('No rows in section ' + sectionTitle);
        return allRows[allRows.length - 1];
    }
    return document.getElementById(lastRowId + '');
}
function log(content, color, sectionTitle){
    // let outlet = document.querySelector(`[data-attr = ${sectionTitle}]`) ?? document.getElementById(lastRowId + '');
    let outlet = getLastRowFromSection(sectionTitle);
    let span = document.createElement('span');
    span.innerText = content;
    if (color) span.style.color = color;
    outlet.appendChild(span);
}
function newLogSection(sectionTitle){
    let outlet = document.getElementById('outlet');
    let newSection = document.createElement('div');
    newSection.classList.add('section');
    newSection.setAttribute('data-title', sectionTitle.replace(/ /g,''));
    newSection.innerHTML = `<h3>${sectionTitle}</h3>`;
    outlet.appendChild(newSection);
}

function newLogRow(sectionTitle){
    lastRowId += 1;
    sectionTitle = sectionTitle == undefined ? undefined : sectionTitle.replace(/ /g,'')
    let outlet = document.querySelector(`[data-title = "${sectionTitle}"]`) ?? document.getElementById('outlet');
    let newRow = document.createElement('div');
    newRow.classList.add('row');
    newRow.setAttribute('id', lastRowId + '');
    outlet.appendChild(newRow);
}
function endSection(){
    let outlet = document.getElementById('outlet');
    let hr = document.createElement('div');
    hr.classList.add('sectionSeparator')
    hr.innerHTML = '<hr>'
    outlet.appendChild(hr);
    newLogRow();
}

newLogRow();



// ************* TIMER **************

class Timer{
    constructor(){
        this.currentTime = 0;
        this.timer = null;
    }
    startTimer(){
        this.timer = setInterval(()=>{
            this.currentTime += 10;
        },10)
    }
    stopTimer(){
        clearInterval(this.timer);
    }
    resetTimer(){
        this.currentTime = 0;
    }
    getCurrentTime(){
        return this.currentTime;
    }
}



//*************************** 
// EXAMPLES
//*****************
let SECTION_1 = 'Async function returns a promise';

let resolveFunctionFactory = function(timeout, logSectionTitle){
    return function(msgStart, msgEnd, msgResolve){
        let signature = `  [[resolve${timeout}]]: `
        if(msgStart || msgEnd) newLogRow(logSectionTitle);
        if(msgStart) log(signature + msgStart, 'white', logSectionTitle);
        return new Promise(resolve => {
            setTimeout(function() {
                resolve(signature + msgResolve);
                log(signature + msgEnd, 'white', logSectionTitle)
            }, timeout)
        })
    }
}
newLogSection(SECTION_1);
let resolve100 = resolveFunctionFactory(100, SECTION_1);
let resolve150 = resolveFunctionFactory(150, SECTION_1);

async function asyncBug1(){
    let a = await resolve100(' [start async1] ', ' [end async1] ', ' resolved bug1');
    log(a, 'green', SECTION_1)
    return ' some str '; // WILL return a promise anyway
}
log(asyncBug1(), 'yellow', SECTION_1);
// This works
// [[resolve100]]: [start async1] [object Promise] [[resolve100]]: [end async1] [[resolve100]]: resolved bug1
// but [object Promise] is returned, as an async function always returns a PROMISE
// To know the actual value returne by asyncBug1, a wrapper could help

async function asyncBug1Wrapper(){
    let result = await asyncBug1();
    newLogRow(SECTION_1);
    log(result, SECTION_1);
}
asyncBug1Wrapper();

// However the result is still packed in a function, and may not be taken out from async

// **************************************
endSection();

let SECTION_2 = "Attempt to return a value with an async function not having an await statement"
newLogSection(SECTION_2);
newLogRow(SECTION_2);
async function asyncReturnValue(){
    return 1;
}
log(asyncReturnValue(),'white',SECTION_2); // [object Promise]
log(`  A async function always returns a promise, even if a return statement with a concrete value is used`,'#aaa',SECTION_2);

endSection();


// ************** ASYNC execution order ******************
let SECTION_3_1 = "Async execution order - sequential start"
newLogSection(SECTION_3_1);
newLogRow(SECTION_3_1);

let timer = new Timer();

let resolve100_3_1 = resolveFunctionFactory(100, SECTION_3_1);
let resolve150_3_1 = resolveFunctionFactory(150, SECTION_3_1);

async function sequentialStartRace(){
    timer.startTimer();
    let f1 = await resolve100_3_1(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_1);
    log(timer.getCurrentTime(), 'green', SECTION_3_1);
    newLogRow(SECTION_3_1);
    let f2 = await resolve150_3_1(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_1);
    log(timer.getCurrentTime(), 'green', SECTION_3_1);
    newLogRow(SECTION_3_1);
    timer.stopTimer();
}
sequentialStartRace();


let timer2 = new Timer();

let SECTION_3_2 = "Async execution order - concurrent start"
newLogSection(SECTION_3_2);
newLogRow(SECTION_3_2);


let resolve100_3_2 = resolveFunctionFactory(100, SECTION_3_2);
let resolve150_3_2 = resolveFunctionFactory(150, SECTION_3_2);

async function concurrentStartRace(){
    // timer2.startTimer();
    let f1 = resolve100_3_2(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_2);
    log(timer2.getCurrentTime(), 'green', SECTION_3_2);
    newLogRow(SECTION_3_2);
    let f2 = resolve150_3_2(' [started] ', ' [ended] ', ' [resolved] ')
    newLogRow(SECTION_3_2);
    log(timer2.getCurrentTime(), 'green', SECTION_3_2);
    newLogRow(SECTION_3_2);
    // timer2.stopTimer();
    // return (f2)
}
async function concurrentStartRaceWrapper(){
    timer2.startTimer();
    let result = await concurrentStartRace();
    log(timer2.getCurrentTime(), 'green', SECTION_3_2);
    timer2.stopTimer();
    log(`
    Timer shows 0, as wrapped function returns only the default promise, if 
    it had a return f2 or return f1 statement then the time of settling this promise would be 
    visible. In this example both functions start at the same time, and promise related to f1 would be resolved after
    100ms, and promise related to f2 would be resolved after 150ms
    `, '#aaa', SECTION_3_2)
}

concurrentStartRaceWrapper();






let timer3 = new Timer();

let SECTION_3_3 = "Async execution order - promise.all"
newLogSection(SECTION_3_3);
newLogRow(SECTION_3_3);


let resolve100_3_3 = resolveFunctionFactory(100, SECTION_3_3);
let resolve150_3_3 = resolveFunctionFactory(150, SECTION_3_3);



async function promiseAllRace(){
    timer3.startTimer();

    await Promise.all([
        (async()=>{
            let resolved = await resolve100_3_3(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_3);
            newLogRow(SECTION_3_3);
            // resolve(resolved);
        })(),
        (async()=>{
            let resolved = await resolve150_3_3(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_3);
            newLogRow(SECTION_3_3);
            // resolve(resolved);
        })()
    ])
    log(timer3.getCurrentTime(), 'green', SECTION_3_3);
    timer3.stopTimer();
}


promiseAllRace();
log(`Both start at the same time, then the first one (100) finishes, and then the second one (150)`
, '#aaa', SECTION_3_3);






let timer4 = new Timer();

let SECTION_3_4 = "Async execution order - promise.reace"
newLogSection(SECTION_3_4);
newLogRow(SECTION_3_4);


let resolve100_3_4 = resolveFunctionFactory(100, SECTION_3_4);
let resolve150_3_4 = resolveFunctionFactory(150, SECTION_3_4);



async function promiseRaceRace(){
    timer4.startTimer();

    await Promise.race([
        (async()=>{
            let resolved = await resolve100_3_4(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_4);
            newLogRow(SECTION_3_4);
            // resolve(resolved);
        })(),
        (async()=>{
            let resolved = await resolve150_3_4(' start ', ' end' ,' resolved ')
            log(timer3.getCurrentTime(), 'green', SECTION_3_4);
            newLogRow(SECTION_3_4);
            // resolve(resolved);
        })()
    ])
    log(timer4.getCurrentTime(), 'green', SECTION_3_4);
    timer4.stopTimer();
}


promiseRaceRace();
log(`Both promises are resolved, but the first one is returned as a result of the promise race`
, '#aaa', SECTION_3_4);



// *************************************
// Promises then catch finally

function rejectFunctionFactory(timeout, logSection){
    return function(reason){
        let rejectedPromise = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                newLogRow(logSection);
                log('[[ Rejected ]]: ', reason);
                reject(reason)
            }, timeout)
        })
    }
}
function resolveFunctionFactory2(timeout, logSection){
    return function(value){
        let rejectedPromise = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                newLogRow(logSection);
                log('[[ Resolved ]]: ', value)},
                timeout)
        })
    }
}

function throwError(errorAsString){
    throw new Error(errorAsString);
}



let SECTION_4 = ".then, .catch, .finally"
newLogSection(SECTION_4);
newLogRow(SECTION_4);

let resolver = function(value) {newLogRow(SECTION_4); log(value, 'green', SECTION_4)};
let rejecter = function(reason) {newLogRow(SECTION_4); log(value, 'red', SECTION_4)};
reject_100_prom = rejectFunctionFactory(100, SECTION_4);
resolve_120_prom = resolveFunctionFactory2(120, SECTION_4);
resolve_80_prom = resolveFunctionFactory2(80, SECTION_4);

let p = new Promise((resolver, rejecter)=>{
    
});



// **** ANIMATION

// animationTarget

function move(animationTargetId, destination, timeInMiliseconds){
        let framesPerSecond = 24;
        let msInSecond = 1000;
        let framesInterval = Math.floor(framesPerSecond / msInSecond);
        let nrOfFrames = timeInMiliseconds * framesPerSecond / msInSecond;
        let animationTarget = document.getElementById(animationTargetId);
        let {x:xEnd, y:yEnd} = destination;
        let {left: xStart, top: yStart} = animationTarget.getBoundingClientRect();
        let xMovePerFrame = (xEnd - xStart)/nrOfFrames;
        let yMovePerFrame = (yEnd - yStart)/nrOfFrames;
        let {currentX, currentY} = {currentX: xStart, currentY: yStart};
        let currentFrame = 0;
        console.log('move Started')
        let moveEnded = new Promise((resolve) => {
                let interval = setInterval(()=>{
                currentX += xMovePerFrame;
                currentY += yMovePerFrame;
                currentFrame += 1;
                if(currentFrame % 200) console.log(destination)
                animationTarget.style.left = currentX + 'px';
                animationTarget.style.top = currentY + 'px';
                if (currentFrame >= nrOfFrames) {
                    clearInterval(interval);
                    console.log('move resolved')
                    resolve();
                }
            },framesInterval);
        })
        return moveEnded;
    }

function wait(timeInMiliseconds){
    let waitingEnded = new Promise((resolve) => {
        let timeout = setTimeout(()=>{
            console.log('waiting ended')
            resolve();
        }, timeInMiliseconds)
    })
    console.log('waiting')
    return waitingEnded;
}

// move('animationTarget', {x: 500, y:500}, 2000).then(wait(1000)).then(move('animationTarget', {x: -500, y: -500}, 1000));
async function animateAwait(){
    await move('animationTarget', {x: 500, y:500}, 2000)
    await wait(1000)
    await move('animationTarget', {x: 500, y: 100}, 1000);
    await move('animationTarget', {x: 550, y: 1000}, 1000);
    await wait(1000);
    await move('animationTarget', {x: 100, y: 100}, 3000);

}
// animatieAwait();
async function animateThen(){
    // Here it is important to wrap handlers, so they return functions not taking any arguments:
    move('animationTarget', {x:1000, y: 1000}, 3000)
        .then(()=>{return wait(1000)})
        .then(()=>{return move('animationTarget', {x:500,y:500}, 2000)})
        .then(()=>{return wait(3000)})
        .then(()=>{return move('animationTarget', {x:-500,y:-500}, 5000)})
}
async function animateAll(){
    await animateAwait();
    await animateThen();
}
animateAll();













    </script>
    
</body>
</html>